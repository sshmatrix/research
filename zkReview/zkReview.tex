\documentclass[a4paper,10pt]{article}

% ------------------------------------
% packages
\usepackage[a4paper,margin=1in,footnotesep=2.2\baselineskip]{geometry}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{framed}
\usepackage{emoji}
\usepackage[most]{tcolorbox}
\usepackage{fancyhdr}
\usepackage[tracking=true]{microtype}
\usepackage{ragged2e}
\usepackage{listings}
\usepackage{color}
\usepackage{pagecolor}
\usepackage{pdftexcmds}

% ------------------------------------
% checksum = SHA-1
\makeatletter
\ifx\pdf@filemdfivesum\undefined\def\pdf@filemdfivesum#{\mdfivesum file}\fi
\let\filesum\pdf@filemdfivesum
\makeatother

% ------------------------------------
% color definitions
\definecolor{armygreen}{rgb}{0.14, 0.71, 0.15}
\definecolor{darkgreen}{rgb}{0.08, 0.48, 0.18}
\definecolor{darkred}{rgb}{0.86, 0.153, 0.153}
\definecolor{azure}{rgb}{0.0, 0.5, 1.0}
\definecolor{bole}{rgb}{0.82, 0.57, 0.22}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{light-gray}{gray}{0.95}
\definecolor{bg}{HTML}{fcfcfa}
\definecolor{bt}{HTML}{ffebe6}

% ------------------------------------
% code styling
\definecolor{shadecolor}{RGB}{180,180,180}
\newcommand{\code}[1]{\colorbox{shadecolor!30}{\mono{#1}}}
\colorlet{Gray}{gray!20!}
\tcbset{on line, arc=1pt, leftrule=0.25pt,rightrule=0.25pt,toprule=0.25pt,bottomrule=0.25pt,
	boxsep=3pt, left=0pt,right=0pt,top=0pt,bottom=0pt,
	colframe=white,colback=Gray,  
	highlight math style={enhanced}
}
\lstdefinelanguage{Solidity}{
  %keywords={bool, true, false, return, address, bytes32, bytes4, bytes1, bytes, uint256, uint8, uint, string, if, while, else, case, break},
  keywords={},
  keywordstyle=\color{blue}\bfseries,
  %ndkeywords={function,struct, mapping, export, throw, implements, import, this},
  ndkeywords={},
  ndkeywordstyle=\color{darkgreen}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{green}\mono,
  stringstyle=\color{orange}\mono,
  morestring=[b]',
  morestring=[b]",
  mathescape=true,
  literate={=>}{$\rightarrow{}$}{1}
}
\lstset{
  backgroundcolor=\color{light-gray},
  language=Solidity,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\footnotesize\mono},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

% ------------------------------------
% fonts
\newfontfamily\pro[Path=./]{SFMono.ttf}
\newfontfamily\pbold[Path=./]{SFMonoBold.ttf}
\newfontfamily\mono[Path=./]{SFMono.ttf}
\newfontfamily\mbold[Path=./]{SFMonoBold.ttf}

% ------------------------------------
% heading font-size
\usepackage{sectsty}
\usepackage{fontspec}
\sectionfont{\fontsize{12}{15}\selectfont}
\usepackage[utf8]{inputenc}

% ------------------------------------
% footnote positioning
\usepackage[hang,flushmargin,bottom]{footmisc} 

% ------------------------------------
% bibliography
\usepackage[colorlinks=true,
            linkcolor=blue,
            urlcolor=blue,
            citecolor=blue,
            pdfauthor={sshmatrix},
            pdftitle={Helix2 Protocol},
            pdfsubject={Link Service and Protocol},
            pdfkeywords={ethereum, account, abstraction, link, name, decentralised, distributed},
            pdfproducer={sshmatrix},
            pdfcreator={sshmatrix}]{hyperref}
            
% ------------------------------------
% blank footnote
\newcommand\blfootnote[1]{%
	\begingroup
	\renewcommand\thefootnote{}\footnote{#1}%
	\addtocounter{footnote}{-1}%
	\endgroup
}

% ------------------------------------
% header
\pagestyle{fancy}
\fancyhf{}
\lfoot{\footnotesize \mono{\#}\tcbox{\mono{\filesum{\jobname}}}}
\begin{document}
\setcounter{footnote}{0}
\newpage
\topskip15pt

\fancyhead[L]{\footnotesize \mono{author}:\tcbox{\mono{sshmatrix}}}
\fancyhead[R]{{\footnotesize \mono{\href{https://github.com/}{github.com/}}}}
\fancyhead[C]{{\footnotesize \emoji{dna}}}
\fancyfoot[C]{{\footnotesize \mono{\thepage/-}}}
\fancyfoot[R]{{\footnotesize \mono{\today} \emoji{dna}}}

\begin{center}
	\textbf{\Large\pbold{\textls[-40]{Intuitive Interpretation of Non-Interactive Zero-Knowledge Cryptography}}}\\
	\vspace{0.075in}
	\textls[-50]{\mono{A jargon-free approach to understanding zk-SNARKs and zk-STARKs}}\linebreak\linebreak
	\vspace{-0.175in}
	\textls[0]{\mono{Avneet Singh}}\linebreak\linebreak
	\textls[0]{\mono{Interplanetary Company UG}}\linebreak
	\textls[0]{\mono{\href{mailto:sshmatrix@proton.me}{sshmatrix@proton.me}}}\linebreak
\end{center}
\begin{center}
	\textbf{\Large\pbold{ABSTRACT}}\linebreak\linebreak
	\textls[-50]{\mono{zk-SNARKs and zk-STARKs are relatively new concepts in cryptography, yet they are being touted as the next forefront in modern and future crypto tech. In blockchain space specifically, there is great interest in these subfields in the context of zk-Rollups to Layer 1 blockchains such as Ethereum, or as standalone decentralised ledgers with high rates of transactions per second (TPS), e.g. Aztec Network (zk-STARK), zkSync, Loopring, ZCash (zk-SNARKs) etc. Despite their great importance in cryptography, it is unfortunately difficult to understand zk-SNARKs and zk-STARKs due to limited literature and conceivably difficult mathematics conveyed through intensive jargon. This paper is an attempt to introduce zero-knowledge (zk) cryptography in an intuitive manner to garden-variety mathematicians, physicists, curious blockchain developers and perhaps even cryptographers.}}
\end{center}
\vspace{0.2in}
\begin{flushleft}
	\textbf{\Large\pbold{INTRODUCTION}}\linebreak\linebreak
	\textls[-50]{\mono{Zero-knowledge cryptography is presumably the next natural stage in cryptography's evolution toward post-quantum era. zk-SNARKs and zk-STARKs are specific implementations of zero-knowledge cryptography that are widely considered the most promising path toward post-quantum security. In order to deeply understand zero-knowledge cryptography, one must at least understand the current generation cryptographic systems such as RSA (Rivest–Shamir–Adleman) and Elliptic Curve Cryptography (ECC); this is admittingly a challenging task since the mathematics of such protocols is rather tedious and it only gets exponentially worse as one ventures in zero-knowledge protocols. Despite these challenges, it is nonetheless easier to understand at least the philosophy and intuition behind zero-knowledge protocols using the famous Alibaba Cave example [1] without requiring any prerequisite knowledge of RSA or ECC. We leave this as an exercise for the reader. In this paper, we will attempt to delve into the practical implementation of zero-knowledge protocols while retaining an intuitive understanding of the underlying mathematical processes.\linebreak\linebreak
	}}
	\colorbox{Gray}{\hspace{1mm}\parbox{0.99\textwidth}{\vspace{1mm}\textls[-50]{\mono{Through the course of this paper, we will leave additional comments in a grey box targeted at physicists, mathematicians and developers. These comments are anecdotes, comparisons or similariries noted across different fields that may help readers develop an intuitive understanding.\vspace{1mm}}}}}
\end{flushleft}
\begin{flushleft}
	\textls[-50]{\mono{Cryptographic protocols at their core are motivated by the need to prove access to some information without necessarily revealing a part or the entirety of said information. In mathematical terms, there are several ways of achieving this functionality from an intelligently designed system.\linebreak
	}}
\end{flushleft}
\begin{flushleft}
	\textbf{\large\pbold{PRIME NUMBERS}}\linebreak\linebreak
	\textls[-50]{\mono{Cryptographers realised back in the day that prime numbers were one such system that could provide such a functionality. For instance, consider two sufficiently large prime numbers {\pbold{a}} = 53781811 and {\pbold{b}} = 23252729, and their even larger product {\pbold{a}}$\,\times\,${\pbold{b}} = 1250573876312219. The product 1250573876312219 is a relatively difficult number to prime factorise back to {\pbold{a}} and {\pbold{b}} if both {\pbold{a}} and {\pbold{b}} are unknown. However, if either one of the two prime factors ({\pbold{a}} or {\pbold{b}}) are known, then it is straightforward to calculate the other unknown prime factor by simple division. To intuitively understand this system further, let's break it down into its principle components: we took a set of very large prime numbers of which {\pbold{a}} and {\pbold{b}} are members and defined an operation of multiplication\textsuperscript{\textcolor{blue}{1}}\blfootnote{\textls[-50]{\mono{\textsuperscript{1}in addition to implicitly defining the operation of addition '+' and its inverse subtraction '-'}}} on the members of the set. Additionally, we note that the product operation $\times$ is difficult to invert unless one of the two numbers is known; this kind of a system is usually called a trapdoor.\linebreak\linebreak 
	}}
	\colorbox{Gray}{\hspace{1mm}\parbox{1.0\textwidth}{\vspace{1mm}\textls[-50]{\mono{In abstract mathematics, such a system is called a group and the study of groups is called Group theory; a group is defined by a set of elements (called a field, e.g. large prime numbers) along with the set of permitted operations between those elements (e.g. multiplication). The configuration of any trapdoor system is such that the permitted operations defined on the elements of the group are difficult to invert.\vspace{1mm}}}}}\linebreak\linebreak
	\textls[-50]{\mono{This trapdoor feature of our chosen system is essentially the backbone of all present day cryptography.\linebreak\linebreak
	}}
	\textbf{\large\pbold{RSA CRYPTOGRAPHY}}\linebreak\linebreak
	\textls[-50]{\mono{RSA protocol is one of the simplest implementations of the trapdoor feature which results in a keypair system (public key and private/secret key). The premise of the RSA protocol essentially lies in setting, i) public key as the qualitative equivalent of the product {\pbold{a}}$\,\times\,${\pbold{b}}, and ii) private key as the qualitative equivalent of either {\pbold{a}} or {\pbold{b}}, where {\pbold{a}} and {\pbold{b}} are restricted to a finite field of prime numbers (denoted by F\textsubscript{prime}). The security of such a system is encoded in the difficulty of prime factorising the product. It is unimportant to know the precise details of the protocol implementation in context of this paper. In nutshell, the RSA algorithm requires solving for the coefficients of Bezout's Identity using extended Euclidean algorithm [2] and employing modular arithmetic to wrap integer numbers when they fall outside the finite prime field F\textsubscript{prime}.\linebreak\linebreak
	}}
	\textbf{\normalsize\pbold{RSA SAFETY}}\linebreak\linebreak
	\textls[-50]{\mono{While RSA is sufficiently safe to use today, it's safety will decrease over time as computational capacity of human civilisation increases. This is because the fastest and - arguably - maximally efficient algorithms capable of inverting the {\pbold{a}}$\,\times\,${\pbold{b}} product are iterative by construction and rely on optimised brute-forcing; Quadratic Sieve [3] and General Number Field Sieve [4] are two such well-known methods. With the advent of quantum computers, RSA algorithm's security will be definitively compromised; this is the so called SNDL problem (Save-Now-Decrypt-Later) facing the cryptography community today [5].\linebreak\linebreak 
	}}
	\textbf{\large\pbold{ELLIPTIC CURVE CRYPTOGRAPHY}}\linebreak\linebreak
	\textls[-50]{\mono{The fundamental issue that leads to the breakdown of RSA algorithm is that the prime number field and the operation of multiplication is not complex enough in the face of large computational power. The effort to improve on this problem led to the advent of Elliptic Curve Cryptography (ECC). ECC functions by fixing the core illnesses in RSA, i.e. it proposes that instead of operating on the prime number field itself, we operate on another field on which we define a newer set of operations that are much harder to invert.  \linebreak\linebreak 
	}}
\end{flushleft}
\begin{flushleft}
	\textbf{\Large\pbold{REFERENCES}}\linebreak\linebreak
		\textls[-50]{\mono{
			[1] Quisquater, JJ. et al. (1990), \href{https://doi.org/10.1007/0-387-34805-0_60}{How to Explain Zero-Knowledge Protocols to Your Children}, Lecture Notes in Computer Science, Vol. 435, Springer, New York, NY\linebreak
		}}
		\textls[-50]{\mono{
			[2] Extended Euclidean Algorithm\linebreak
		}}
		\textls[-50]{\mono{
			[3] Quadratic Sieve Algorithm\linebreak
		}}
		\textls[-50]{\mono{
			[4] General Number Field Sieve Algorithm\linebreak
		}}
		\textls[-50]{\mono{
			[5] SNDL Problem\linebreak
		}}
\end{flushleft}
\begin{flushright}
	\textbf{\large\pbold{METADATA}}\linebreak\linebreak
	\textls[-50]{\mono{
		\mono{Github: }\tcbox{}\linebreak
		\mono{Contracts: }\tcbox{}\linebreak
		\mono{Source: }\tcbox{}\linebreak
		\mono{SHA-1 Checksum: }\tcbox{}\linebreak
		\mono{Date: }\tcbox{\mono{\today}}\linebreak
	}}
\end{flushright}
\end{document}
